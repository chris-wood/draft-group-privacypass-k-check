{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-22T01:43:57.889329+00:00",
  "repo": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "discuss",
      "description": "",
      "color": "F37263"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJv72Bc5pzdtY",
      "title": "Enforce a minimum validity time?",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/1",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If the resource can get refreshed very frequently (like every second), a client could still be targeted without detecting an attack. One solution is to have a minimum time for validity.",
      "createdAt": "2023-06-26T15:54:23Z",
      "updatedAt": "2023-09-08T16:02:33Z",
      "closedAt": "2023-07-06T11:30:18Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "You could also have the mirror police the keys being distributed to make sure that key rotations seem reasonable, and there's not a flipping between keys that could look like targeting.",
          "createdAt": "2023-06-26T15:57:35Z",
          "updatedAt": "2023-06-26T15:57:35Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Or ensure that enough clients saw this key before the key changed...",
          "createdAt": "2023-06-26T16:01:09Z",
          "updatedAt": "2023-06-26T16:01:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "[From @dvorak42](https://github.com/chris-wood/draft-group-privacypass-k-check/pull/2#discussion_r1245310746).",
          "createdAt": "2023-06-28T14:40:47Z",
          "updatedAt": "2023-06-28T14:40:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "#2 includes a minimum validity time as a mirror configuration parameter. ",
          "createdAt": "2023-06-29T14:05:02Z",
          "updatedAt": "2023-06-29T14:05:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved by #2.",
          "createdAt": "2023-07-06T11:30:18Z",
          "updatedAt": "2023-07-06T11:30:18Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this needs some more motivation.  If clients only initiate sessions using currently-fresh resources, then short validity windows do not provide any ability to target individual clients (ignoring clock skew).\r\n\r\nI would like to see some more specific rationale for this recommendation, if it is necessary at all.",
          "createdAt": "2023-09-08T16:02:33Z",
          "updatedAt": "2023-09-08T16:02:33Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOJv72Bc5rHLZC",
      "title": "Consistency at the end of key validity",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/5",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If a key config doesn't cover its expiry time, a client could potentially have checked a key as being valid and continue to use it over time as long as it sees challenges from the origin using that key.\r\n\r\nHowever, if the key had actually rotated for everyone else, a client may be targeted by being the only one in the set still using an old key.",
      "createdAt": "2023-07-10T15:42:52Z",
      "updatedAt": "2023-07-10T15:46:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding a `not-after` value to a key mitigates this for the scheduled rotation cases.",
          "createdAt": "2023-07-10T15:44:47Z",
          "updatedAt": "2023-07-10T15:44:47Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Alternatively, the k-check proxy could tell clients about the cadence to check in",
          "createdAt": "2023-07-10T15:46:06Z",
          "updatedAt": "2023-07-10T15:46:06Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJv72Bc5tqMz-",
      "title": "Batched fetching for k-check.",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/7",
      "state": "OPEN",
      "author": "dvorak42",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For some use cases, it is useful to be able to fetch multiple configurations at the same time to reduce the number of fetches/ensure consistency across multiple resources.\r\n\r\nThis tracks adding a batched mode for the client to request a bundle/batch of resource requests.",
      "createdAt": "2023-08-07T15:58:20Z",
      "updatedAt": "2023-10-02T15:45:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a technical reason why requesting multiple resources in parallel work for this use case? H2 and H3 handle parallel requests quite well.",
          "createdAt": "2023-08-08T14:52:35Z",
          "updatedAt": "2023-08-08T14:52:35Z"
        },
        {
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "body": "I'm not sure of the spelling, but effectively we want the client to say \"please give me all the FOO configurations\" (ie please give me all the PST issuer configurations).\r\n\r\nThe current way of doing this might be to fetch a \"FOO_directory\" resource that lists all the configuration resource identifiers and then run a bunch of parallel requests for each of those resources, but now we have at least one extra hop for the directory fetch. ",
          "createdAt": "2023-08-14T13:48:16Z",
          "updatedAt": "2023-08-14T13:48:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Is that extra hop -- especially for an offline step -- really worth complicating the protocol?",
          "createdAt": "2023-08-15T17:55:38Z",
          "updatedAt": "2023-08-15T17:55:38Z"
        },
        {
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "body": "My gut is that at scale, one resource request vs 11 (assuming around 10 issuer configurations) would have a substantial impact on latency and bandwidth for the K-check service (and caching) even with parallel requests. Though maybe CDNs have already solved some of the caching/bandwidth issues (local caching of results?) that K-check servers can rely on?",
          "createdAt": "2023-08-17T14:04:53Z",
          "updatedAt": "2023-08-17T14:04:53Z"
        },
        {
          "author": "smhendrickson",
          "authorAssociation": "NONE",
          "body": "We discussed this again today. Although it does seem like a common use case per https://github.com/chris-wood/draft-group-privacypass-k-check/issues/7#issuecomment-1682349612, H3 will help per https://github.com/chris-wood/draft-group-privacypass-k-check/issues/7#issuecomment-1669775776. \r\n\r\n@dvorak42  are you ok deferring this feature to keep the spec simpler in its initial iteration?",
          "createdAt": "2023-09-25T15:58:52Z",
          "updatedAt": "2023-09-25T15:58:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Another possible use case for batching is for DAP aggregator public keys, i.e., to ensure that clients have a consistent view of the aggregator keys. It might be necessary for these keys to be consistent for all aggregators at once, rather than individually for each aggregator.",
          "createdAt": "2023-10-02T15:45:33Z",
          "updatedAt": "2023-10-02T15:45:33Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJv72Bc5u2DuQ",
      "title": "Thundering herd at expiration time",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/8",
      "state": "OPEN",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "Consider adding a deployment consideration comment about how to avoid the thundering herd problem.",
      "createdAt": "2023-08-21T15:45:45Z",
      "updatedAt": "2024-03-11T16:32:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sysrqb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Double-check contains the following recommendation:\r\n```\r\nAll clients of the same Proxy and Desired Resource will have locally cached copies with the same expiration time. When this copy expires, all active clients will send refresh GET requests to the Proxy at their next request. Proxies SHOULD use \"request coalescing\" to avoid duplicate cache-refresh requests to the Origin.\r\n\r\nIf the Desired Resource has changed, these clients will all initiate GET requests to the Origin (via transport proxy if applicable) to double-check the new contents. Proxies and Origins MAY use an HTTP 503 response with a \"Retry-After\" header to manage load spikes.\r\n```\r\n\r\nAlternatively, clients could re-check/refresh/update their cached keys at some (relatively small) offset, chosen at random, from the expiration time. This wouldn't prevent a spike around the expiration time, but this would at least smooth the spike a bit. Ben Schwartz has an interesting idea of how to do this safely.",
          "createdAt": "2023-08-28T15:28:23Z",
          "updatedAt": "2023-08-28T15:28:23Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The best solution I've thought of is to define each profile as providing a \"ladder\" comprising a pair of resources (perhaps distinguished by a request header).  The client fetches both, which are cached independently, and verifies that that they indicate the same configurations during the overlap in their cache lifetimes.  After the first expiration, the client picks a random time before the second one expires to refresh the first one.  This ensures that refresh requests are not clustered near expiration times, and allows us to continue using the Mirror Protocol as-is.  (Mirrors do not need to be aware of the ladder semantics.)  However, it doubles the number of requests, and complicates the deployment for origins.",
          "createdAt": "2023-09-08T16:14:22Z",
          "updatedAt": "2023-09-08T16:14:22Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Another approach is to generally recommend that clients fetch resources from the mirror as they need to use the resource (if I don't need to fetch a token, then I don't check the key when the key expires). For these less frequent cases, they shouldn't have a thundering herd.\r\n\r\nFor resources that are used very frequently, clients should avoid fetching the mirror resource at the exact time of expiration, and should have some jitter around that (potentially aligned to when they'd fetch a resource based on use anyway)",
          "createdAt": "2023-10-16T15:48:30Z",
          "updatedAt": "2023-10-16T15:48:30Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For these less frequent cases, they shouldn't have a thundering herd.\r\n\r\nYes: if the use frequency is long relative to the cache lifetime, then we don't expect clustering of refreshes at expiration points.  (Assuming on-demand validation, which seems like the reasonable default despite some concerns about timing correlations.)\r\n\r\n> For resources that are used very frequently, clients should avoid fetching the mirror resource at the exact time of expiration, and should have some jitter around that\r\n\r\nI don't think this works.  Fetches prior to the expiration time don't help: they just return a mirror resource that is about to expire.  Using the fetched resource after the expiration time is unsafe in two ways: it may be invalid (leading to failure) and you may be the only client still using it (leading to deanonymization).",
          "createdAt": "2023-10-16T16:05:55Z",
          "updatedAt": "2023-10-16T16:05:55Z"
        },
        {
          "author": "sysrqb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for raising this issue Ben, and giving some guidance on how to solve it. I wrote some text around this. It takes a simpler approach that puts some responsibility on the service/origin, instead of describing a more complicated client-side chaining/ladder solution. Some implementations may benefit from chaining multiple resources, with different expiration periods, but that seems out of scope for the core protocol at this time. If there is interest in specifying this from the group, then we will discuss adding it in a later version of the draft.",
          "createdAt": "2023-10-18T19:53:59Z",
          "updatedAt": "2023-10-18T19:53:59Z"
        },
        {
          "author": "sysrqb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Happy to continue the discussion from https://github.com/chris-wood/draft-group-privacypass-consistency-mirror/pull/21#discussion_r1365720273 if there is more that we need to consider.",
          "createdAt": "2023-10-23T15:25:45Z",
          "updatedAt": "2023-10-23T15:25:45Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ultimately, the options I see are:\r\n\r\n* There is only one copy of the resource in use.  Thundering herd at replacement time.\r\n* There are two or more copies of the resource in use with staggered lifetimes.  No thundering herd, but someone has to check that both copies are equivalent during the overlap in their lifetimes.\r\n  - Clients fetch both and check: \"ladder\" strategy as above (https://github.com/chris-wood/draft-group-privacypass-consistency-mirror/issues/8#issuecomment-1711918025)\r\n  - The mirror understands the resource and performs the equivalence check before updating its cache (a \"smart mirror\" strategy).\r\n\r\nThe \"ladder\" strategy seems preferable to me because the \"smart mirror\" approach has some issues:\r\n\r\n* It creates ossification risk (mirrors need to add support for new formats before they can be used).\r\n* It doesn't support novel uses of mirrors beyond consistency checking.\r\n* It creates a risk of consistency failures if the mirror and the clients have different interpretations of the resource.",
          "createdAt": "2023-10-23T16:54:40Z",
          "updatedAt": "2023-10-23T16:54:40Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOJv72Bc5wTmOc",
      "title": "Incorrect statement about Mirror's response format",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/9",
      "state": "CLOSED",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nOtherwise, the response to a mirror request is the content that was contained in the target resource. \r\n```\r\n\r\nThis conflicts with the later statement that the response is encoded using BHTTP. Probably we should just delete this sentence.",
      "createdAt": "2023-09-06T14:49:30Z",
      "updatedAt": "2023-09-25T14:46:43Z",
      "closedAt": "2023-09-25T14:46:43Z",
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOJv72Bc5wT5uc",
      "title": "Consider ensuring end-to-end configuration authenticity",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/10",
      "state": "CLOSED",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The client may not have a mechanism for verifying that a configuration is authentic - only consistent within the assumptions of the design. For Privacy Pass, the client already processes a cryptographic key from which it derives the keyid and the client trusts that its set of K-Check mirrors won't collude with the origin. A similar situation exists with other profiles, such as OHTTP.\r\n\r\nOne suggestion we received is requiring self-authenticating configurations.",
      "createdAt": "2023-09-06T15:28:35Z",
      "updatedAt": "2023-10-18T20:37:06Z",
      "closedAt": "2023-10-18T20:37:05Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Specifically, K-Check appears to weaken the security of OHTTP.  Normally, OHTTP guarantees authenticity and privacy as long as at least one of the proxy or the gateway is well-behaved.  With K-Check, authenticity and privacy can fail even if the gateway is well-behaved, if the K-Check mirrors collude to impersonate the gateway.\r\n\r\nEDIT: I think the most practical solution to this is to simply note the problem and recommend that K-Check only be used with self-authenticating resources.  A more aggressive solution would be to specify JSON Web Signature or HTTP Signed Exchange as the supported resource type.",
          "createdAt": "2023-09-08T16:09:41Z",
          "updatedAt": "2023-09-08T16:11:15Z"
        },
        {
          "author": "sysrqb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there is an unstated assumption somewhere in here. Can you help clarify?\r\n\r\nI agree with the privacy and authenticity guarantees you described, without using K-Check, as long as the relay and gateway don't collude and at least one of them is well-behaved. The underlying assumption here is that the client was pre-configured with the gateway's key configuration and that configuration was consistent with all other clients of this service (eliding the need for K-Check, in this case).\r\n\r\nIn the case where the client must check the consistency of the configuration it has, then we can still assume the client was pre-configured with that configuration. If the client has multiple K-Check servers configured, then if a majority of those servers collude, then they can persuade the client that the pre-configured configuration is not consistent. This would cause a DoS, but not reduce the guarantees of the service.\r\n\r\nWere you thinking of different assumptions? Maybe the client isn't pre-configured with the key configuration and it must fetch (or update) its cache?",
          "createdAt": "2023-09-17T19:45:32Z",
          "updatedAt": "2023-09-17T19:45:32Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The underlying assumption here is that the client was pre-configured with the gateway's key configuration\r\n\r\nTo be precise, I'm imagining \"normal OHTTP\" to work by pre-configuring the client with a URL for the gateway's key configuration, which the client fetches over an authenticated transport (i.e. \"direct discovery\").  As written, the K-Check document seems to _replace_ this step, by fetching via the mirror pool.  If the intention is instead to _augment_ the authenticated fetch, the document should say so.  However, that would be very similar to DoubleCheck, and raises some of the same issues:\r\n\r\n1. Direct discovery (without a transport proxy with a suitable trust model) reveals the client IP addresses to the gateway.  While this doesn't directly break the unlinkability guarantees, it creates a significant weakness when joined with external behavioral profiles (see also #15), and a near-total break if timing correlations are present (i.e., config fetch immediately precedes config use, see #14).\r\n2. Direct discovery exacerbates the [Thundering Herd problem](https://datatracker.ietf.org/doc/html/draft-schwartz-ohai-consistency-doublecheck-03#name-thundering-herds) when the target resource changes.",
          "createdAt": "2023-09-18T14:20:38Z",
          "updatedAt": "2023-09-18T14:20:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> As written, the K-Check document seems to replace this step, by fetching via the mirror pool. \r\n\r\nThis isn't the case. K-Check _complements_ this check. It assumes that the input key material was obtained in some authoritative fashion (thereby knowing that it's \"correct\"), and its purpose is to check that this is the same key shared by others (checking if it's \"consistent\").",
          "createdAt": "2023-09-18T15:36:21Z",
          "updatedAt": "2023-09-18T15:36:21Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, thanks for the explanation.  For this issue, I think it would be sufficient to clarify that in the document.\r\n\r\nAs noted in #16, I'm not sure it's always a good idea to draw a total abstraction boundary between correctness and consistency.  If the correctness validation procedure (or subsequent use) relies on a privacy proxy, then the K-Check procedure can safely be simplified to K=1, with improved privacy.",
          "createdAt": "2023-09-18T16:53:01Z",
          "updatedAt": "2023-09-18T16:53:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> As noted in https://github.com/chris-wood/draft-group-privacypass-k-check/issues/16, I'm not sure it's always a good idea to draw a total abstraction boundary between correctness and consistency. If the correctness validation procedure (or subsequent use) relies on a privacy proxy, then the K-Check procedure can safely be simplified to K=1, with improved privacy.\r\n\r\nIt doesn't necessarily rely on a privacy proxy, which is why the separation exists. As an example, clients do not necessarily need to hide their IP address from an OHTTP gateway if they fetch the config directly from it. The whole point of the consistency check is to ensure that their config is, well, consistent with every other client (using the same set of mirrors), regardless of how they happened to obtain the authenticated copy. ",
          "createdAt": "2023-09-18T19:14:33Z",
          "updatedAt": "2023-09-18T19:14:33Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm totally OK with defining K-Check (or perhaps the Mirror Protocol) as a limited-purpose component that is separate from authentication and usage of the resource.  Currently, the draft is not clear on that point; I came away with the impression that K-Check was also being used for authentication (which it does provide under certain, slightly worrying security assumptions).\r\n\r\nI do think that usage of K-Check is actually not as independent from the protocol as the current text implies, but that's a topic for a different issue.",
          "createdAt": "2023-09-18T20:03:05Z",
          "updatedAt": "2023-09-18T20:03:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sysrqb do we want to keep this open? I think self-certifying configurations are somewhat orthogonal to the core work here. ",
          "createdAt": "2023-09-25T19:35:42Z",
          "updatedAt": "2023-09-25T19:35:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this as resolved, since resources can be self-certifying on top of the mirror protocol without requiring any changes. Please feel free to re-open as needed.",
          "createdAt": "2023-10-18T20:37:05Z",
          "updatedAt": "2023-10-18T20:37:05Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOJv72Bc5wT85H",
      "title": "Rely on a quorum of mirrors",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/11",
      "state": "CLOSED",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently we describe the failure mode based on some probability of mirror failure/misbehavior. This can be improved.\r\n\r\n```\r\nWith at least one dishonest mirror, the probability of discovering an inconsistency is 1 - (1 / 2^(k-1)). This is the probability that each individual mirror check succeeds in the mirror protocol.\r\n```\r\n\r\nOne suggestion we received is using a concept of quorum instead.",
      "createdAt": "2023-09-06T15:35:49Z",
      "updatedAt": "2023-10-18T20:36:05Z",
      "closedAt": "2023-10-18T20:36:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can safely close this now.",
          "createdAt": "2023-10-18T20:36:05Z",
          "updatedAt": "2023-10-18T20:36:05Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOJv72Bc5xTu1a",
      "title": "Increasing K creates a privacy risk when timing correlations are present",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/14",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "K-Check is designed to improve in ~privacy~ resistance to active attack as K (or the threshold `t`) increases.  However, if a timing correlation is present (e.g., the client fetches an OHTTP config immediately before using it), increasing K ~actually reduces privacy~ increases vulnerability to a passive attack on the user's privacy, because any single colluding mirror can reveal the client IP to the gateway.  Adding more mirrors increases the likelihood that one of them is malicious.\r\n\r\nIf timing attacks are present in the use case, I think the optimal value of K is likely to be 1.\r\n\r\nIn some use cases, timing correlations are present for some requests (e.g., the first request issued when the configuration is not locally in cache) but not others.  In these cases, it might make sense to perform a single check (K=1) initially, and then perform more checks asynchronously (according to some randomized schedule) to catch if the initial mirror was colluding and served a targeted resource.\r\n\r\nThese issues can be avoided by tunneling K-Check through a trusted proxy, but if a trusted proxy exists then it can run the Mirror Protocol itself and K > 1 is unnecessary (see #16).",
      "createdAt": "2023-09-18T13:53:09Z",
      "updatedAt": "2024-01-09T15:03:18Z",
      "closedAt": "2024-01-09T15:03:17Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> K-Check is designed to improve in privacy as K (or the threshold t) increases\r\n\r\nI don't think this is a goal of K-Check. Increasing K is meant to increase confidence in consistency of the answer -- it has nothing to do with privacy. Does the draft say otherwise? If so, we should probably fix that.",
          "createdAt": "2023-09-19T21:45:15Z",
          "updatedAt": "2023-09-19T21:45:15Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've adjusted the issue description to be more precise, and avoid assuming that privacy is the only reason to pursue consistency.",
          "createdAt": "2023-09-20T18:45:38Z",
          "updatedAt": "2023-09-20T18:45:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I understand this newly phrased issue. The \"attack\" is still described as one on privacy (\"increasing K actually reduces privacy increases vulnerability to a passive attack on the user's privacy\"). I appreciate thinking about the draft, but it would be more helpful if this was something concrete.",
          "createdAt": "2023-09-20T18:52:21Z",
          "updatedAt": "2023-09-20T18:52:21Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I'll try to make it concrete.  A hypothetical example:\r\n\r\nI am the moderator of a subreddit.  I'm trying to maintain my privacy, so my login handle is not identifying.  Once every day or two, I publish a comment in the subreddit using OHTTP through a trustworthy Relay.\r\n\r\nA hostile actor would like to know my IP address.  Reddit doesn't know, and the Relay won't share.  However, Reddit's gateway config expires after 60 minutes, so almost every time I post an update, my client app needs to refresh its consistency check first.  That requires pinging K different mirrors, asking for Reddit's gateway config.  Let's say K=10.\r\n\r\nIt turns out that one of those 10 mirrors is compromised by the hostile actor.  By correlating requests for the gateway config with my post timestamps, it can identify the IP address that always asked for this resource immediately before my posts appeared.  That's my IP address.\r\n\r\nThe risk of one mirror being compromised increases in proportion to K.  Similar proportional risks apply to correlation attacks using passive network monitoring, which become more likely as your requests traverse more paths.",
          "createdAt": "2023-09-20T19:50:33Z",
          "updatedAt": "2023-09-20T19:50:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, so this _is_ an attack on privacy \ud83d\udc4d We can certainly note that the probability of such a thing increases as K increases.",
          "createdAt": "2023-09-25T19:34:27Z",
          "updatedAt": "2023-09-25T19:34:27Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is resolved by #19.",
          "createdAt": "2024-01-09T15:03:17Z",
          "updatedAt": "2024-01-09T15:03:17Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOJv72Bc5xT8hE",
      "title": "Consider client IP pool leakage",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/15",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "In K-Check, the mirrors appear to learn the client IPs.  (There is no requirement to access the mirrors only via a trusted transport proxy.)  Even if the colluding parties aren't able to correlate the individual client IPs to specific requests (e.g. via a timing attack as in #14), a malicious mirror could reveal the entire IP pool to the target.  The target may be able to join configuration use with externally available information about the client IPs to deanonymize requests.\r\n\r\nFor example, consider a web search use case over OHTTP, with a client IP pool of 1,000 users.  If a search query arrives for a topic that is only of interest to 10% of users, in a language spoken by 10% of users, from a user-agent used by 10% of users, then the search provider might be able to use an external user profiling database to identify one client IP in the pool that is likely to be the source of that request.\r\n\r\nA possible mitigation would be to avoid using more than X% of the total pool of mirrors and keep that subset stable over time.  This reduces the likelihood that any single mirror can leak more than a fraction of the total client IP pool.  If one of the mirrors is colluding, the target only learns X% of the client IP pool.  This means that even if one client IP has a profile that is highly consistent with a particular request, there is also a significant possibility that the request came from some other, unknown client IP.",
      "createdAt": "2023-09-18T14:19:41Z",
      "updatedAt": "2024-03-11T16:30:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the call: address this via deployment specific considerations, stating that use cases which may need to hide the IP from mirrors should proxy requests. Also note the potential chicken-and-egg problem that can arise if one is using OHTTP to run K-Check for OHTTP!",
          "createdAt": "2023-09-18T15:57:26Z",
          "updatedAt": "2023-09-18T15:57:26Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOJv72Bc5xUDiP",
      "title": "Recommend K=1 for certain use cases",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/16",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The K-Check protocol is described as an abstract, general-purpose consistency protocol, and in that context it makes sense for K to be a free parameter.  However, in specific use cases there may be particular values of K that make sense.  If the client's privacy protection is already subject to a Single Point of Failure, then the optimal value for K is 1, i.e. a mirror operated by the SPOF.\r\n\r\nFor example, in OHTTP, increasing K does not provide increased privacy protection, because a malicious Relay can break the privacy guarantee even if consistency is preserved.  Increasing K can even reduce privacy protection (see #14, #15).\r\n\r\nAccordingly, the draft should note some cases where K=1 is recommended.",
      "createdAt": "2023-09-18T14:33:44Z",
      "updatedAt": "2023-09-25T18:39:52Z",
      "closedAt": "2023-09-25T18:39:52Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I understand the motivation for this, but I'm not confident we can make generally applicable recommendations. At best, it seems like we might be able to provide examples where certain values of K = 1. OHTTP is an obvious case for that. Would that work?\r\n\r\nSeparately, to make sure we're on the same page, does this issue assume that K is chosen for privacy reasons?",
          "createdAt": "2023-09-19T21:50:34Z",
          "updatedAt": "2023-09-19T21:50:34Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do think there is a generally applicable recommendation here.  I've written it up in #17.",
          "createdAt": "2023-09-20T19:07:20Z",
          "updatedAt": "2023-09-20T19:07:20Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOJv72Bc5x8-ff",
      "title": "Discuss behavior on failed consistency checks",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/18",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If you check only one mirror, and consistency fails, you can check another mirror, etc. However, the behavior when you end up with inconsistency in general, the client application needs local policy on what to do.\r\n\r\n- If the feature that is inconsistent is optional, the client can just not do it. (Privacy pass helps avoid captchas, but if the key is not consistent, just don't use privacy pass, and show the captcha)\r\n- If the feature is required, but there is a fallback option, use that. (Use a different privacy pass provider, use a different OHTTP/ODoH server, one that is consistent).\r\n- If the feature is required, and all options are inconsistent, fail hard and/or throw an alert. (Private relay would declare an outage if all ODoH servers had invalid keys)",
      "createdAt": "2023-09-25T15:48:01Z",
      "updatedAt": "2023-10-09T15:42:05Z",
      "closedAt": "2023-10-09T15:42:05Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Add a new section before security considerations",
          "createdAt": "2023-09-25T15:52:37Z",
          "updatedAt": "2023-09-25T15:52:37Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOJv72Bc54Zdta",
      "title": "Freshness vs. age",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/23",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When talking about caching at a mirror, the minimum retention uses the following phrase:\r\n\r\n> their \"max-age\" response directive.\r\n\r\nYou want \"[freshness lifetime](https://datatracker.ietf.org/doc/html/rfc9111#name-freshness)\".",
      "createdAt": "2023-12-01T02:42:07Z",
      "updatedAt": "2023-12-01T02:42:07Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOJv72Bc54aO45",
      "title": "Does this really need binary HTTP?",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/25",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "I like RFC 9292, but it seems like maybe it is unnecessary for this use case.  The reason that RFC 9292 is used here appears to be that the header fields from the request that the mirror makes of the mirrored resource need to make it to the client.  However, there is no end-to-end integrity protection for the resource.  It would be simpler if the mirror resource were to provide a media type and copy the content directly.",
      "createdAt": "2023-12-01T05:48:52Z",
      "updatedAt": "2024-03-11T16:30:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason we chose BHTTP was to encapsulate the origin's response in its entirety down to the client, including the headers, as then clients have all possible information to make their consistency decisions.",
          "createdAt": "2024-01-31T00:31:33Z",
          "updatedAt": "2024-01-31T00:31:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "So maybe I don't understand the proposal, but it doesn't really describe how this protocol is expected to integrate into an actual consistency scheme.  Here was my understanding:\r\n\r\n0. Client obtains a URL for a resource and has secondary information that suggests that consistency and correctness is important for the resource.\r\n1. The client requests that resource.[^1]\r\n2. The client asks a mirror (or mirrors) using the protocol in this draft.\r\n\r\nThe direct request establishes correctness.  The mirror requests establish consistency.\r\n\r\nFor consistency, it is true that resource metadata can alter the way in which content is interpreted.  In theory at least, if you only ensure consistency of content, you might leave open the possibility of an attack.  [Polyglot formats](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a) are the most obvious way to have that happen, but that is very much more theory than practice.  Altering processing logic based on the value of a header field happens, but it shouldn't be part of any design that relies on consistency.  The only exception being content type.\r\n\r\nThe risks from altered header fields (or trailer fields...!) can be addressed by accepting a single format, or by only altering processing rules based on information that the mirror will supply.\r\n\r\nPractically speaking, content type covers all cases I'm aware of.  Indeed, the only case for which content type is relevant is making sure that you have a way to add new features to an existing protocol; and only when those features are not compatible with the existing format.  That case also has other ramifications for consistency, meaning that in most cases a single format remains the best option all around.\r\n\r\nThe problem with getting all the headers is that you then have to embark on a game of determining which are relevant to the consistency game.  Date?  Probably not.  Cache-Control?  I suggest that it is better to just look at the content and *maybe* the content type.\r\n\r\n[^1]: It might do so via an intermediary (OHTTP or MASQUE) to hide its identity, but a choice like that is largely orthogonal to the consistency question.  I say \"largely\" because it make it harder for the server to use client identity as the basis for client-specific adaptations, which would undermine consistency.",
          "createdAt": "2024-01-31T03:53:39Z",
          "updatedAt": "2024-01-31T03:53:39Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOJv72Bc54aREn",
      "title": "Cache lifetime on mirrored resources",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/26",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The mirror is not a cache of the identified resource, it is creating a resource with its own identity. Therefore, it could have an independent freshness lifetime.\r\n\r\nIf you remove the bhttp envelope as #25 suggests, then you will totally lose information about freshness of the original.  However, I believe that a mirror only exists to validate the bytes: a client should have a copy of the resource direct from the authoritative source that contains authoritative information about freshness lifetimes.  (Because mirrors cannot be used to establish the authenticity of content, only its consistency.)\r\n\r\nThe mirror could use (or is it abuse?) targeted cache control fields for the purpose of providing information about what the mirror received from the authoritative source, but I'm struggling to come up with a really good reason to pass that information along.",
      "createdAt": "2023-12-01T05:55:21Z",
      "updatedAt": "2023-12-01T05:55:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOJv72Bc54aRkh",
      "title": "Mirrors cannot be used to establish the authenticity of content",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/27",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This really needs to be said a few times: *mirrors cannot be used to establish the authenticity of content, only its consistency*.\r\n\r\nPlease consider adding that to the security considerations.",
      "createdAt": "2023-12-01T05:57:04Z",
      "updatedAt": "2023-12-01T05:57:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 28,
      "id": "I_kwDOJv72Bc54aTvA",
      "title": "Consistency period",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/28",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> Consistency only holds for the period of time of the minimum mirror validity window.\r\n\r\nThis is, a pessimistic take, but maybe not the most pessimistic.  In addition, you can't make guarantees about future or past consistency.  That is, you could be at the start of a validity window (such that consistency holds into the future), at the end (such that consistency holds into the past), or anywhere in between.\r\n\r\nIf you have multiple mirrors, you might be able to get consistency for the minimum window into the past and into the future, but you can't bank on that either.",
      "createdAt": "2023-12-01T06:03:03Z",
      "updatedAt": "2023-12-01T06:03:03Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOJv72Bc54aWq-",
      "title": "Defection probability",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/29",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think that this is potentially misleading:\r\n\r\n> With at least one dishonest mirror, the probability of discovering an inconsistency is 1 - (1 / 2^(k-1)), where k is the number of disjoint consistency checks. This is the probability that each individual consistency check succeeds.\r\n\r\nThis assumes that mirrors are selected at random, which is almost never the case.\r\n\r\nA client is never subject to attack as long as they use one honest mirror.  They are only subject to denial of service if they discover the inconsistency.  Maybe.  It could depend on client policy.  For instance, if the client has 5 low quality mirrors and 1 defects, they might ignore the defector and carry on.\r\n\r\nA client that uses a single dishonest mirror might be subject to an attack if the canonical source of information colludes with the dishonest mirror.  That extends to the case where all mirrors and the canonical source collude.\r\n\r\nThis analysis only applies if a client chooses a mirror at random from a set of k mirrors that contains a single dishonest mirror.  I am not sure how many deployments would use that sort of random sampling.\r\n\r\nIn the end, I'd suggest that this concentrate on what happens AFTER a client has selected a set of mirrors.  And note that there are different policies that clients can implement.",
      "createdAt": "2023-12-01T06:11:26Z",
      "updatedAt": "2023-12-01T06:11:26Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 31,
      "id": "I_kwDOJv72Bc57cGSR",
      "title": "How does config rotation work?",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/31",
      "state": "OPEN",
      "author": "ehaydenr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "I'm thinking of the following scenario:\r\n\r\n- t=0 OHTTP Gateway gives config A to mirror with validity of 10 mins\r\n- t=5min OHTTP Gateway wants to rotate config to config B\r\n- t=6min client fetches config from OHTTP gateway, gets config B\r\n- t=6min client goes to mirror and is provided config A because it's still valid in cache. Inconsistency\r\n\r\nIf the client is checking multiple mirrors, a similar inconsistency could happen since mirrors will be refreshing their cache at different times.",
      "createdAt": "2024-01-08T17:57:32Z",
      "updatedAt": "2024-03-11T16:29:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a misconfiguration for the gateway since they specified a validity window that was longer than that which was actually used in practice. I think the expectation is that the cache validity must always be less than the lifetime of the resource.",
          "createdAt": "2024-01-08T18:39:25Z",
          "updatedAt": "2024-01-08T18:39:25Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "NONE",
          "body": "What would a valid rotation timeline look like?\r\n\r\nIf I'm an OHTTP gateway that normally advertises a 10 minute validity window, do I have to disable caching of my configuration altogether for at least 10 minutes so no mirrors cache while I rotate?\r\n\r\nEven if I did that, I think there's still this race condition:\r\n- right before gateway config rotation, client fetches from gateway (tiny/no validity window)\r\n- gateway rotates\r\n- client goes to mirror, gets the new config.. inconsistency",
          "createdAt": "2024-01-08T19:07:50Z",
          "updatedAt": "2024-01-08T19:07:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ehaydenr by gateway are you referring to an OHTTP gateway, or the origin which provides the source of truth for a resource? \r\n\r\nIn any case, I think you're right that this race condition will exist even if there were no cache controls on the resource. Probably the simplest way to deal with this is for clients to retry their request to the gateway after the mirror to see if the resource has changed. Since the error path here depends on client policy, i.e., does it treat mismatches as failures and abort, does it retry the whole flow, etc, I think it's reasonable to treat this as an edge case that implementations work around.  \r\n\r\n@tfpauly, thoughts?",
          "createdAt": "2024-01-30T23:17:38Z",
          "updatedAt": "2024-01-30T23:17:38Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOJv72Bc57kwvc",
      "title": "Content negotiation or protocol evolution for the target resource",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/32",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If a resource has multiple representations, that is potentially OK, but also very close to what an inconsistent resource would do.  \r\n\r\nIt is probably best to avoid content negotiation for resources that need consistency, but that might constrain evolution of protocols through the use of different media types.  It would be unfortunate if the only evolution option is through the use of different URLs, if only because that creates similar problems to content negotiation in that the choice of which URL to use is something an adversary might seek to exploit.\r\n\r\nIt seems possible to ensure that - for a given request profile - the resource is consistent, but it would require some care.  Putting in place some constraints on usage might make it possible to have content negotiation or a choice of URLs without creating an exploitable variation.",
      "createdAt": "2024-01-09T21:55:10Z",
      "updatedAt": "2024-01-09T21:55:10Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 33,
      "id": "I_kwDOJv72Bc6BuTBs",
      "title": "Support well-known resource declaring all valid keys",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/33",
      "state": "OPEN",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From the adoption call:\r\n\r\n```\r\nFor Privacy Pass specifically, I think it is worth defining an OPTIONAL endpoint /.well-known/mirror-resource\r\nthat would allow clients to retrieve all issuer keys before discovering it when prompted by an Origin. A\r\nsimilar endpoint is provided in Cloudflare attester implementation [2] for instance. This endpoint could be as\r\nsimple as a list:\r\nGET /.well-known/mirror-resources\r\nhttps://issuer1.example/.well-known/private-token-issuer-directory\r\nhttps://issuer2.example/.well-known/private-token-issuer-directory\r\n```",
      "createdAt": "2024-03-08T16:44:06Z",
      "updatedAt": "2024-03-08T16:44:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 34,
      "id": "I_kwDOJv72Bc6BuTa9",
      "title": "Mention CORS?",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/issues/34",
      "state": "OPEN",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From the adoption call:\r\n\r\n```\r\nIt would be interesting to mention how this setup interact with CORS in the\r\nWeb environment. An issuer could restrict their responses to attester.example/* for instance.\r\nThe use of wrapped response would not benefit from this sanitasation.\r\n```",
      "createdAt": "2024-03-08T16:45:13Z",
      "updatedAt": "2024-03-08T16:45:13Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "PR_kwDOJv72Bc5UBxwa",
      "title": "Improve mirror protocol",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-27T12:23:49Z",
      "updatedAt": "2023-06-29T14:06:10Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "589d00fd0754d45aa1f790086b8a177f7fbd94e7",
      "headRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "headRefName": "caw/better",
      "headRefOid": "3ea27d1d3ee5edc046da4c593f23246024dd5f6c",
      "closedAt": "2023-06-29T14:06:09Z",
      "mergedAt": "2023-06-29T14:06:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5417e54a7a7c32ba33c8bfb05cc201bd6738162e"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That looks fine \ud83d\udc4d ",
          "createdAt": "2023-06-28T16:12:49Z",
          "updatedAt": "2023-06-28T16:12:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5ZmcrR",
          "commit": {
            "abbreviatedOid": "84aa982"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-28T14:28:44Z",
          "updatedAt": "2023-06-28T14:32:19Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I wonder if the mirror should just be enforcing this. It doesn't seem possible for the mirror to enforce max validity windows without making these decisions locally (it can't tell max-age=10 seconds means that the resource caching is too low or it has just hit the resource towards the end of its lifetime.",
              "createdAt": "2023-06-28T14:28:44Z",
              "updatedAt": "2023-06-28T14:32:19Z"
            },
            {
              "originalPosition": 59,
              "body": "Should this take into account the Accept header from the client? ",
              "createdAt": "2023-06-28T14:30:34Z",
              "updatedAt": "2023-06-28T14:32:19Z"
            },
            {
              "originalPosition": 79,
              "body": "Should there be logic for network/server errors from the target not accidentally polluting the mirror's cache for some temporary outage?",
              "createdAt": "2023-06-28T14:31:37Z",
              "updatedAt": "2023-06-28T14:32:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5Zmm0m",
          "commit": {
            "abbreviatedOid": "84aa982"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-28T14:40:18Z",
          "updatedAt": "2023-06-28T14:40:18Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Yeah, maybe. Let's track this in #1.",
              "createdAt": "2023-06-28T14:40:18Z",
              "updatedAt": "2023-06-28T14:40:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5Zmnr_",
          "commit": {
            "abbreviatedOid": "84aa982"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-28T14:41:53Z",
          "updatedAt": "2023-06-28T14:41:53Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "As in, should the mirror, uh, mirror the Accept header from the client in its request to the target? If so, that seems like a good idea.",
              "createdAt": "2023-06-28T14:41:53Z",
              "updatedAt": "2023-06-28T14:41:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5Zmn10",
          "commit": {
            "abbreviatedOid": "84aa982"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-28T14:42:08Z",
          "updatedAt": "2023-06-28T14:42:09Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "We probably should have a path for this, yeah. I'll add it.",
              "createdAt": "2023-06-28T14:42:08Z",
              "updatedAt": "2023-06-28T14:42:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5ZmpCw",
          "commit": {
            "abbreviatedOid": "84aa982"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-28T14:43:55Z",
          "updatedAt": "2023-06-28T14:43:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJv72Bc5Zm0X7",
          "commit": {
            "abbreviatedOid": "84aa982"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-28T15:03:28Z",
          "updatedAt": "2023-06-28T15:03:28Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Yeah, since different clients may expect different things or accept different variants/content-types. Though this might also complicate the caching logic if different Accept values result in different resource responses from the target.",
              "createdAt": "2023-06-28T15:03:28Z",
              "updatedAt": "2023-06-28T15:03:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5ZtIJP",
          "commit": {
            "abbreviatedOid": "84aa982"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-29T10:26:05Z",
          "updatedAt": "2023-06-29T10:26:05Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Looking at this again, there's already text above which says that mirror replies to clients with 4xx if the mirror request fails for any reasons. ",
              "createdAt": "2023-06-29T10:26:05Z",
              "updatedAt": "2023-06-29T10:26:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5Zuj72",
          "commit": {
            "abbreviatedOid": "84aa982"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-29T14:06:04Z",
          "updatedAt": "2023-06-29T14:06:05Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I had to check the spec, but it turns out that Accept doesn't complicate caching as much as the Vary header, so I left this in.",
              "createdAt": "2023-06-29T14:06:05Z",
              "updatedAt": "2023-06-29T14:06:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOJv72Bc5UUn3e",
      "title": "Align with main consistency document",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-30T11:14:48Z",
      "updatedAt": "2023-07-06T11:30:04Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "5417e54a7a7c32ba33c8bfb05cc201bd6738162e",
      "headRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "headRefName": "caw/align",
      "headRefOid": "0556dcbdfc68033ca630d0fb97bdd6b22b46621f",
      "closedAt": "2023-07-06T11:30:03Z",
      "mergedAt": "2023-07-06T11:30:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f6baeff15a7550ab185e6699ed91a0b318b62507"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5aRz4J",
          "commit": {
            "abbreviatedOid": "d10fec3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-05T14:07:33Z",
          "updatedAt": "2023-07-05T14:13:59Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nHTTP in which privacy goals require that clients have a consistent view of some protocol-specific\r\n```\r\nI personally find \"wherein\" a bit formal",
              "createdAt": "2023-07-05T14:07:33Z",
              "updatedAt": "2023-07-05T14:13:59Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nDeployments of protocols such as Privacy Pass and OHTTP requires that very large sets of clients\r\nshare the same key, or even that all clients globally share the same key. This is because the privacy properties depend on the client\r\n```",
              "createdAt": "2023-07-05T14:09:48Z",
              "updatedAt": "2023-07-05T14:13:59Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\na particular client belongs. Using a unique, client-specific key would yield an anonymity set\r\n```",
              "createdAt": "2023-07-05T14:10:06Z",
              "updatedAt": "2023-07-05T14:13:59Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nuse the same key as one another are said to have a consistent view of the key.\r\n```",
              "createdAt": "2023-07-05T14:10:24Z",
              "updatedAt": "2023-07-05T14:13:59Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\na concrete instantiation of one of those designs, \"Shared Cache Discovery\". In particular,\r\n```",
              "createdAt": "2023-07-05T14:11:06Z",
              "updatedAt": "2023-07-05T14:13:59Z"
            },
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nThe mirror protocol is a simple HTTP-based protocol similar to a reverse proxy. Each mirror\r\n```",
              "createdAt": "2023-07-05T14:13:42Z",
              "updatedAt": "2023-07-05T14:13:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOJv72Bc5VGHjr",
      "title": "First come first serve check",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/4",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T14:43:27Z",
      "updatedAt": "2023-07-10T18:43:05Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "f6baeff15a7550ab185e6699ed91a0b318b62507",
      "headRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "headRefName": "caw/fcfs",
      "headRefOid": "52d8126151e245aab23c8f02b476bf8d0f1007a1",
      "closedAt": "2023-07-10T18:43:05Z",
      "mergedAt": "2023-07-10T18:43:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "105824414905afdaed8a987e3a59da7d576e3bfa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5avJ91",
          "commit": {
            "abbreviatedOid": "da86a05"
          },
          "author": "sysrqb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T15:05:44Z",
          "updatedAt": "2023-07-10T15:08:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Is this saying that the \"first valid representation\" is:\r\n1. The first resource, sorted by \"not-before\" value, if present\r\n1. Otherwise, the first resource, sorted lexicographically by keyid?",
              "createdAt": "2023-07-10T15:05:44Z",
              "updatedAt": "2023-07-10T15:08:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5avQjl",
          "commit": {
            "abbreviatedOid": "da86a05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-10T15:18:43Z",
          "updatedAt": "2023-07-10T15:18:43Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "It's saying that it's the first key in the list that the client would attempt to use. ",
              "createdAt": "2023-07-10T15:18:43Z",
              "updatedAt": "2023-07-10T15:18:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5avRIq",
          "commit": {
            "abbreviatedOid": "da86a05"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T15:19:58Z",
          "updatedAt": "2023-07-10T15:20:01Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Might be nice to clarify \"the first valid representation (the first entry in the list that the client is able to use)\"...",
              "createdAt": "2023-07-10T15:19:58Z",
              "updatedAt": "2023-07-10T15:20:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5avRfs",
          "commit": {
            "abbreviatedOid": "da86a05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-10T15:20:43Z",
          "updatedAt": "2023-07-10T15:20:44Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nClients compute the first valid representation of this directory, i.e., the first entry in the list that the client can use, which might be the key ID\r\n```",
              "createdAt": "2023-07-10T15:20:44Z",
              "updatedAt": "2023-07-10T15:20:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5avRju",
          "commit": {
            "abbreviatedOid": "da86a05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-10T15:20:51Z",
          "updatedAt": "2023-07-10T15:20:52Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yep, done!",
              "createdAt": "2023-07-10T15:20:51Z",
              "updatedAt": "2023-07-10T15:20:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOJv72Bc5VIHXy",
      "title": "Add as author",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/6",
      "state": "MERGED",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T20:22:29Z",
      "updatedAt": "2023-07-10T20:23:19Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "1f50e3d918735dd1c9a52d6d9612d6ee1bb07bec",
      "headRepository": "sysrqb/draft-group-privacypass-consistency-mirror",
      "headRefName": "author",
      "headRefOid": "31a1b48b73140f1bc7898be1208989cb0a11e81c",
      "closedAt": "2023-07-10T20:23:19Z",
      "mergedAt": "2023-07-10T20:23:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "57dd72defef1180f256bde8a29171b365366dce3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5axuzp",
          "commit": {
            "abbreviatedOid": "31a1b48"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T20:23:12Z",
          "updatedAt": "2023-07-10T20:23:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOJv72Bc5ag9Ym",
      "title": "Fix a few sentences that cause confusion, and fix a typo",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/12",
      "state": "MERGED",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #9 ",
      "createdAt": "2023-09-17T20:29:21Z",
      "updatedAt": "2023-09-25T14:46:42Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "57dd72defef1180f256bde8a29171b365366dce3",
      "headRepository": "sysrqb/draft-group-privacypass-consistency-mirror",
      "headRefName": "readability-improvements",
      "headRefOid": "b9efb2bfbaeb070c70ed310bee7bef418a89b537",
      "closedAt": "2023-09-25T14:46:42Z",
      "mergedAt": "2023-09-25T14:46:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1a3aba485acfe582269dee43b48a65ccfa6f7090"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5hPL0-",
          "commit": {
            "abbreviatedOid": "b9efb2b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-18T15:34:57Z",
          "updatedAt": "2023-09-18T15:34:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOJv72Bc5ahAM8",
      "title": "Define success with respect to a threshold of mirrors",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/13",
      "state": "CLOSED",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #11 ",
      "createdAt": "2023-09-17T21:26:35Z",
      "updatedAt": "2023-10-10T21:24:09Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "57dd72defef1180f256bde8a29171b365366dce3",
      "headRepository": "sysrqb/draft-group-privacypass-consistency-mirror",
      "headRefName": "mirror_threshold",
      "headRefOid": "46b1e1ff2c5d57d083da353b8bffdc89fcd89096",
      "closedAt": "2023-10-10T21:24:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as overcome by events.",
          "createdAt": "2023-10-10T21:24:09Z",
          "updatedAt": "2023-10-10T21:24:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOJv72Bc5a0JNd",
      "title": "Add a section discussing K=1 cases",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/17",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #16",
      "createdAt": "2023-09-20T19:05:25Z",
      "updatedAt": "2023-09-26T14:19:19Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "57dd72defef1180f256bde8a29171b365366dce3",
      "headRepository": "bemasc/draft-group-privacypass-k-check",
      "headRefName": "patch-1",
      "headRefOid": "639af5d702e536f8bf862e1e2bb1cdb2f7847877",
      "closedAt": "2023-09-25T18:39:51Z",
      "mergedAt": "2023-09-25T18:39:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "91642013c071a89348b6b21e929ccaa127fe0c32"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5hiG7h",
          "commit": {
            "abbreviatedOid": "8c94e29"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-20T19:11:18Z",
          "updatedAt": "2023-09-20T19:11:18Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Again, how does increasing K impair _security_?",
              "createdAt": "2023-09-20T19:11:18Z",
              "updatedAt": "2023-09-20T19:11:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5hiG-g",
          "commit": {
            "abbreviatedOid": "8c94e29"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-20T19:11:25Z",
          "updatedAt": "2023-09-20T19:11:25Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nPrivacy Pass it is typically the Attester.\r\n```",
              "createdAt": "2023-09-20T19:11:25Z",
              "updatedAt": "2023-09-20T19:11:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5hiJmt",
          "commit": {
            "abbreviatedOid": "f9af101"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-20T19:19:06Z",
          "updatedAt": "2023-09-20T19:27:55Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "OK, I've changed this to \"... is often the Attester\".  (\"Typically\" seems too strong, given the joint Issuer-Attester and other models.)\r\n\r\nEDIT: Thinking about this some more, I've expanded it to \"... might be the Attester (in Split Mode) or a transport proxy\", and added a paragraph noting that the In-Band Consistency proposal is probably better if you can use it.",
              "createdAt": "2023-09-20T19:19:06Z",
              "updatedAt": "2023-09-21T14:37:40Z"
            },
            {
              "originalPosition": 20,
              "body": "In this text, I only mean that K=1 doesn't make security worse.  That said, I think increasing K does impair security in this situation, where we have an integrated mirror whose good behavior is already a requirement:\r\n\r\n* In a threshold model,`t > 1` makes the client more vulnerable to denial of service attacks.\r\n* The other mirrors are untrusted, so any risk of collusion attacks (i.e., attacks on consistency) is additional risk here (unless the integrated mirror is on the list and `t == K`, in which case outages/DoS are more likely).",
              "createdAt": "2023-09-20T19:26:21Z",
              "updatedAt": "2023-09-20T19:27:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5h5MFi",
          "commit": {
            "abbreviatedOid": "7443485"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-25T15:00:29Z",
          "updatedAt": "2023-09-25T15:01:18Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nsufficiently large anonymity set.  Mirror availability is also important, so\r\nthat users do not lose access to the system.\r\n```",
              "createdAt": "2023-09-25T15:00:29Z",
              "updatedAt": "2023-09-25T15:01:18Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nthe client's activity to additional parties and reduces the likelihood of an outage.\r\n```\r\nas \"impair security or privacy\" requires more text, so the simpler thing seems to just be deleting it altogether.",
              "createdAt": "2023-09-25T15:01:16Z",
              "updatedAt": "2023-09-25T15:01:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOJv72Bc5bKOzG",
      "title": "Simplify to K=1 and somewhat punt consistency policies to the application",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/19",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This partly addresses #11 and #14, but not entirely. We need some more considerations about timing correlations, application policies for dealing with consistency check failures, and so on before those issues are resolved.",
      "createdAt": "2023-09-25T19:37:06Z",
      "updatedAt": "2023-09-26T19:25:09Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "91642013c071a89348b6b21e929ccaa127fe0c32",
      "headRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "headRefName": "caw/k-is-one",
      "headRefOid": "f0ad6423441907057467e111aedc8f1925b24e1b",
      "closedAt": "2023-09-26T19:25:09Z",
      "mergedAt": "2023-09-26T19:25:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a0658d1d39b7bee93f7802e103bc5be79a254642"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5h7DSy",
          "commit": {
            "abbreviatedOid": "f0ad642"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-25T19:38:46Z",
          "updatedAt": "2023-09-25T19:39:20Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Which considerations? Is this a place to link to failure considerations in a later section?",
              "createdAt": "2023-09-25T19:38:46Z",
              "updatedAt": "2023-09-25T19:39:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5h7DuY",
          "commit": {
            "abbreviatedOid": "f0ad642"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-25T19:40:05Z",
          "updatedAt": "2023-09-25T19:40:05Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "It could be a link to the failure considerations or they could be inlined here, yeah. Whatever reads better.",
              "createdAt": "2023-09-25T19:40:05Z",
              "updatedAt": "2023-09-25T19:40:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5h7UjQ",
          "commit": {
            "abbreviatedOid": "f0ad642"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-25T20:30:11Z",
          "updatedAt": "2023-09-25T20:30:11Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Got it",
              "createdAt": "2023-09-25T20:30:11Z",
              "updatedAt": "2023-09-25T20:30:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 20,
      "id": "PR_kwDOJv72Bc5cJVaL",
      "title": "Explaining consistency failure handling",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/20",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #18",
      "createdAt": "2023-10-06T20:02:14Z",
      "updatedAt": "2023-10-09T15:42:03Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "22b5f14e6aad2a9bc942c83ff1a74de980641d77",
      "headRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "baba2f91c46e770c268ebeed5f26076ea82de8ec",
      "closedAt": "2023-10-09T15:42:03Z",
      "mergedAt": "2023-10-09T15:42:03Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "9bdfe0e48bf79299015d0cf7c231546f7e08e1a7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5jOo5b",
          "commit": {
            "abbreviatedOid": "c84485a"
          },
          "author": "sysrqb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T15:27:30Z",
          "updatedAt": "2023-10-09T15:35:14Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "nit: `s/the presents/that presents/`",
              "createdAt": "2023-10-09T15:27:31Z",
              "updatedAt": "2023-10-09T15:35:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5jOvU4",
          "commit": {
            "abbreviatedOid": "c84485a"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T15:36:33Z",
          "updatedAt": "2023-10-09T15:36:34Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nerror in a visible way that presents the error to the user or an administrator. This\r\n```",
              "createdAt": "2023-10-09T15:36:33Z",
              "updatedAt": "2023-10-09T15:36:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5jOv5u",
          "commit": {
            "abbreviatedOid": "e182b14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-09T15:37:20Z",
          "updatedAt": "2023-10-09T15:37:37Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\nerror in a visible way that presents the error to the user or an administrator. This\n```\n",
              "createdAt": "2023-10-09T15:37:21Z",
              "updatedAt": "2023-10-09T15:37:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5jOx_Q",
          "commit": {
            "abbreviatedOid": "e182b14"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T15:40:16Z",
          "updatedAt": "2023-10-09T15:40:16Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nIf a consistency check fails because the mirrored resource did not match, the client\r\nMUST NOT use the original resource. For cases where the check failed because the\r\nclient was unable to communicate with the mirror, client policy dictates whether or\r\nnot to assume the resource is consistent. Client behavior for what to do in the case\r\nof inconsistency can vary depending on the protocol, availability of alternative services,\r\nand client policy.\r\n```",
              "createdAt": "2023-10-09T15:40:16Z",
              "updatedAt": "2023-10-09T15:40:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOJv72Bc5dLqrM",
      "title": "Add some guidance on re-checking consistency",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/21",
      "state": "MERGED",
      "author": "sysrqb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T19:35:08Z",
      "updatedAt": "2023-10-23T16:55:27Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "eac85f3cbf621a58a551ccccf0bc5622b9830b22",
      "headRepository": "sysrqb/draft-group-privacypass-consistency-mirror",
      "headRefName": "rechecking_consistency",
      "headRefOid": "f55dd04a378dfbfa83509b20feb5625d0ad10e01",
      "closedAt": "2023-10-23T15:29:48Z",
      "mergedAt": "2023-10-23T15:29:48Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dec7fbbbc9efbbca24d7e18040b58fe80f720419"
      },
      "comments": [
        {
          "author": "sysrqb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closes #8 ",
          "createdAt": "2023-10-18T19:44:51Z",
          "updatedAt": "2023-10-18T19:44:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJv72Bc5kfkja",
          "commit": {
            "abbreviatedOid": "dbcce9b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T19:47:13Z",
          "updatedAt": "2023-10-18T19:54:02Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n1. Pre-emptively execute a consistency check for a resource that is expiring soon; and\r\n```",
              "createdAt": "2023-10-18T19:47:13Z",
              "updatedAt": "2023-10-18T19:54:02Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n1. Execute a consistency check of an expired resource at the time of its next use.\r\n```",
              "createdAt": "2023-10-18T19:47:19Z",
              "updatedAt": "2023-10-18T19:54:02Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nFor strategy 1, clients that execute consistency checks at the same time can\r\ninduce a thundering herd that overwhelms the mirror resource. Since coordinating\r\nconsistency checks across clients is difficult, clients can instead execute consistency\r\nchecks at random times before the resource expires. Clients that have more information\r\nabout a mirror's available capacity can choose different implementations for strategy 1.\r\n```",
              "createdAt": "2023-10-18T19:53:08Z",
              "updatedAt": "2023-10-18T19:54:02Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nused. However, a consequence of this strategy is that it can reveal a client's\r\nusage patterns to the mirror.\r\n```",
              "createdAt": "2023-10-18T19:53:50Z",
              "updatedAt": "2023-10-18T19:54:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5kgD9E",
          "commit": {
            "abbreviatedOid": "f55dd04"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T20:54:23Z",
          "updatedAt": "2023-10-18T20:54:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJv72Bc5knTOs",
          "commit": {
            "abbreviatedOid": "f55dd04"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T15:15:45Z",
          "updatedAt": "2023-10-19T15:15:45Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I don't think this helps.  The resource is only valid until its expiration time, and repeated checking doesn't extend that time.  Once the resource expires, all clients will have to refresh it before they can rely on it again.",
              "createdAt": "2023-10-19T15:15:45Z",
              "updatedAt": "2023-10-19T15:15:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5k5kof",
          "commit": {
            "abbreviatedOid": "f55dd04"
          },
          "author": "sysrqb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T15:02:28Z",
          "updatedAt": "2023-10-23T15:02:40Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "But that's where the following come into play:\r\n```\r\nWhen the origin server has multiple versions of a resource corresponding to a\r\n URL, it should respond with the resource that is both currently valid and will\r\n remain fresh for the longest amount of time in the future.\r\n```\r\n\r\nIn other words, if an origin is correctly configured and has either 1) a new resource that it is rotating to in the (near) future when the current resource expires, or 2) an extended expiration time/period for the current resource, then it should respond with the freshest and long-living answer it has available. Ideally, this will happen at least a few hours before the previous expiration time - if not longer.\r\n\r\nPerhaps, saying this more explicitly, the service should be updated with a new expiration time or resource well before the current expiration time is reached. Do you believe this isn't a reasonable expectation?",
              "createdAt": "2023-10-23T15:02:28Z",
              "updatedAt": "2023-10-23T15:02:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJv72Bc5k6fHf",
          "commit": {
            "abbreviatedOid": "f55dd04"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T16:55:27Z",
          "updatedAt": "2023-10-23T16:55:27Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I don't think this works.  The mirror will serve all responses out of cache until its cached copy expires.  It won't contact the origin server at all before then, so \"early rotation\" by the origin server has no effect.  (The mirror cannot simply update its cached copy early, as this partitions the clients into epochs.)\r\n\r\nMore comments here: https://github.com/chris-wood/draft-group-privacypass-consistency-mirror/issues/8#issuecomment-1775617206",
              "createdAt": "2023-10-23T16:55:27Z",
              "updatedAt": "2023-10-23T16:55:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOJv72Bc5fBxmX",
      "title": "Update Ben's affiliation",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/22",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-09T12:13:04Z",
      "updatedAt": "2023-11-09T15:23:41Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "dec7fbbbc9efbbca24d7e18040b58fe80f720419",
      "headRepository": "beurdouche/draft-group-privacypass-consistency-mirror",
      "headRefName": "main",
      "headRefOid": "018896f25ee7d6335d2dc366d54e03e72782e472",
      "closedAt": "2023-11-09T15:23:40Z",
      "mergedAt": "2023-11-09T15:23:40Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bcc95319765df7bd468c2dd1c2d0e2069b121891"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "PR_kwDOJv72Bc5g2-PN",
      "title": "Use HTTP/1.1 for examples",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/24",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "That's a protocol that was built for this use case.\r\n\r\nThe only gotcha is that this needs RFC 8792 to handle the absurdly long lines that you get from putting one URL inside another.\r\n\r\nThis produces warnings about not citing RFC 8792 directly.  I'm not sure what to do about that.",
      "createdAt": "2023-12-01T05:43:13Z",
      "updatedAt": "2023-12-01T05:44:44Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "bcc95319765df7bd468c2dd1c2d0e2069b121891",
      "headRepository": "martinthomson/consistency-mirror",
      "headRefName": "h11-examples",
      "headRefOid": "1e2d0c345bf842e6ee0ed02b204013a3f64a63f5",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 30,
      "id": "PR_kwDOJv72Bc5jfLuf",
      "title": "Add minor precisions and fix typos",
      "url": "https://github.com/ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror/pull/30",
      "state": "OPEN",
      "author": "thibmeu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Main precision is about max-age returned by the mirror to clients. It should not be the same as the cached request, as this would extend the lifetime of the original request. For privacy pass, this might lead clients to see an invalid key for instance.\r\nI propose to substract the elapsed time, even though it might create spike in traffic as client would be invalidated at the same time.\r\n\r\nOther edits in this PR are typos.",
      "createdAt": "2024-01-08T15:14:57Z",
      "updatedAt": "2024-01-08T15:14:57Z",
      "baseRepository": "ietf-wg-privacypass/draft-ietf-privacypass-consistency-mirror",
      "baseRefName": "main",
      "baseRefOid": "bcc95319765df7bd468c2dd1c2d0e2069b121891",
      "headRepository": "thibmeu/draft-group-privacypass-consistency-mirror",
      "headRefName": "main",
      "headRefOid": "b0c13e0ed90df129e87c9fa8f451737f5cc40ec0",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}